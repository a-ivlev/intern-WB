package pattern

import (
	"errors"
)

/*
	Реализовать паттерн «фабричный метод».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Factory_method_pattern
*/

/*
	Фабричный метод - это порождающий паттерн проектирования, который решает проблему создания различных продуктов,
	без указания конкретных классов продуктов. Фабричный метод задаёт метод, который следует использовать вместо
	вызова оператора new.
	Фабричный метод - это порождающий паттерн проектирования, который определяет общий интерфейс для создания объектов
	в суперклассе, позволяя подклассам изменять тип создаваемых объектов.

	В Go невозможно реализовать классический вариант паттерна Фабричный метод, поскольку в языке отсутствуют возможности
	ООП, в том числе классы и наследственность. Несмотря на это, мы все же можем реализовать базовую версию этого
	паттерна - Простая фабрика.

	Применимость:
	1. Когда заранее не известны типы и зависимости объектов, с которыми должен работать ваш код.

	Фабричный метод отделяет код производства продуктов от остального кода, который эти продукты использует.
	Благодаря этому, код производства можно расширять, не трогая основной. Так, чтобы добавить поддержку нового
	продукта, вам нужно создать новый подкласс и определить в нём фабричный метод, возвращая оттуда экземпляр нового
	продукта.

	2. Когда вы хотите дать возможность пользователям расширять части вашего фреймворка или библиотеки.

	Пользователи могут расширять классы вашего фреймворка через наследование.

	3. Когда вы хотите экономить системные ресурсы, повторно используя уже созданные объекты, вместо порождения новых.

	Такая проблема обычно возникает при работе с тяжёлыми ресурсоёмкими объектами, такими, как подключение к базе данных,
	файловой системе и т.д. Самым удобным местом был бы конструктор объекта, ведь все проверки нужны только при создании
	объекта. Но увы, конструктор всегда создаёт новые объекты, он не может вернуть существующий экземпляр.
	Фабричный метод может отдавать как существующие, так и новые объекты.
*/

var (
	ErrWrongGunType = errors.New("wrong gun type")
)

// Интерфейс продукта
type iGun interface {
	setName(name string)
	setPower(power int)
	getName() string
	getPower() int
}

// Конкретный продукт реализующий интерфейс iGun.
type gun struct {
	name  string
	power int
}

func (g *gun) setName(name string) {
	g.name = name
}

func (g *gun) getName() string {
	return g.name
}

func (g *gun) setPower(power int) {
	g.power = power
}

func (g *gun) getPower() int {
	return g.power
}

// Конкретный продукт реализующий интерфейс iGun.
type ak47 struct {
	gun
}

func newAk47() iGun {
	return &ak47{
		gun{
			name:  "AK 47 gun",
			power: 4,
		},
	}
}

// Конкретный продукт реализующий интерфейс iGun.
type musket struct {
	gun
}

func newMusket() iGun {
	return &musket{
		gun{
			name:  "Musket gun",
			power: 1,
		},
	}
}

// Реализация паттерна Фабрика
func getGun(gunType string) (iGun, error) {
	switch gunType {
	case "ak47":
		return newAk47(), nil
	case "musket":
		return newMusket(), nil
	}
	return nil, ErrWrongGunType
}

//func main() {
//	ak47, _ := getGun("ak47")
//	musket, _ := getGun("musket")
//
//	fmt.Println(ak47.getName())
//	fmt.Println(musket.getName())
//}
