package pattern

import "fmt"

/*
	Реализовать паттерн «стратегия».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Strategy_pattern
*/

/*
	Стратегия - это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает
	каждый из них в собственный класс называемым стратегией, после чего алгоритмы можно взаимозаменять прямо во время
	исполнения программы. Вместо того, чтобы изначальный класс сам выполнял тот или иной алгоритм, он будет играть роль
	контекста, ссылаясь на одну из стратегий и делегируя ей выполнение работы. Чтобы, сменить алгоритм, достаточно
	подставить в контекст другой объект-стратегию. Важно, чтобы все стратегии имели общий интерфейс.

	Применимость:
	1. Когда необходимы использовать разные варианты алгоритма внутри одного объекта.
	Пример: Навигатор имеет разные варианты построения маршрута, когда мы передвигаемся по городу - пешком, на велосипеде,
	на автомобиле, на общественном транспорте.

	2. Когда есть множество похожих объектов отличающихся некоторым поведением.

	3. Когда мы не хотим раскрывать детали реализации алгоритмов для других классов.

	4. Когда есть различные варианты алгоритмов реализованные в виде развесистого условного оператора, т.е. когда
	много разных if else или switch case. Каждая ветка такого оператора представляет собой вариацию алгоритма.
	Нужно обязательно применить паттерн стратегия, чтобы выделить данное поведение в определённый объект.

	Преимущества:
	1. Замена алгоритмов на лету.
	2. Изолирует код и данные алгоритмов от остальных объектов бизнес-логики.
	3. Уход от наследования и делегирования какого-то непосредственно алгоритма.
	4. Реализует принцип открытости/закрытости.

	Недостатки:
	1. Усложнение программы за счёт дополнительных объектов.
	2. Клиент должен знать в чём состоит разница между стратегиями, чтобы выбрать подходящую.
*/

// Интерфейс стратегий с методом вытеснения элементов в кеше.
type strategy interface {
	evict(c *cache)
}

// Конкретная стратегия.
type fifo struct{}

// Метод реализует общий интерфейс strategy, стратегия вытеснения fifo.
func (f *fifo) evict(c *cache) {
	fmt.Println("Evicting by fifo strategy")
}

// Конкретная стратегия.
type lru struct{}

// Метод реализует общий интерфейс strategy, стратегия вытеснения lru.
func (l *lru) evict(c *cache) {
	fmt.Println("Evicting by lru strategy")
}

// Конкретная стратегия.
type lfu struct{}

// Метод реализует общий интерфейс strategy, стратегия вытеснения lfu.
func (f *lfu) evict(c *cache) {
	fmt.Println("Evicting by lfu strategy")
}

// Контекст
type cache struct {
	storage     map[string]string
	strategy    strategy
	capacity    int
	maxCapacity int
}

func initCache(s strategy) *cache {
	storage := make(map[string]string)
	return &cache{
		storage:     storage,
		strategy:    s,
		capacity:    0,
		maxCapacity: 2,
	}
}

func (c *cache) setStrategy(s strategy) {
	c.strategy = s
}

func (c *cache) evict() {
	c.strategy.evict(c)
	c.capacity--
}

func (c *cache) add(key, value string) {
	if c.capacity == c.maxCapacity {
		c.evict()
	}
	c.capacity++
	c.storage[key] = value
}

func (c *cache) get(key string) string {
	return c.storage[key]
}

// func main() {
// 	lfu := &lfu{}
// 	cache := initCache(lfu)

// 	cache.add("a", "1")
// 	cache.add("b", "2")

// 	cache.add("c", "3")

// 	lru := &lru{}
// 	cache.setStrategy(lru)

// 	cache.add("d", "4")

// 	fifo := &fifo{}
// 	cache.setStrategy(fifo)

// 	cache.add("e", "5")
// }
