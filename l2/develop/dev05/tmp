package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
	"strings"

	"github.com/jessevdk/go-flags"
)

/*
=== Утилита grep ===

Реализовать утилиту фильтрации (man grep)

Поддержать флаги:
-A - "after" печатать +N строк после совпадения
-B - "before" печатать +N строк до совпадения
-C - "context" (A+B) печатать ±N строк вокруг совпадения
-c - "count" (количество строк)
-i - "ignore-case" (игнорировать регистр)
-v - "invert" (вместо совпадения, исключать)
-F - "fixed", точное совпадение со строкой, не паттерн
-n - "line num", печатать номер строки

Программа должна проходить все тесты. Код должен проходить проверки go vet и golint.
*/

// Options Работа с флагами.
type Options struct {
	After      int  `short:"A" long:"after" description:"печатать +N строк после совпадения"`
	Before     int  `short:"B" long:"before" description:"печатать +N строк до совпадения"`
	Context    int  `short:"C" long:"context" description:"(A+B) печатать ±N строк вокруг совпадения"`
	Count      bool `short:"c" long:"count" description:"количество строк"`
	IgnoreCase bool `short:"i" long:"ignore-case" description:"игнорировать регистр"`
	Invert     bool `short:"v" long:"invert" description:"вместо совпадения, исключать"`
	Fixed      bool `short:"F" long:"fixed" description:"точное совпадение со строкой, не паттерн"`
	LineNum    bool `short:"n" long:"line-num" description:"печатать номер строки"`
}

var options Options

var parser = flags.NewParser(&options, flags.Default)

// grep читает данные из файла или из STDIN, построчно заносит их в слайс, проверяет на совпадение,
// подсчитывает количество строк. Возвращает два слайса и общее количество прочитанных строк. Полный слайс allInput,
// в котором находятся все прочитанные строки. И resIdx слайс индексов строк, по которым найдены совпадения.
func grep(f io.ReadCloser, findStr string) (allInput []string, resIdx []int, count int) {
	defer f.Close()

	input := bufio.NewScanner(f)
	for input.Scan() {
		line := input.Text()
		// allInput в этот слайс добавляются все прочитанные строки.
		allInput = append(allInput, line)
		// ignoreCase если этот флаг установлен, мы переводим строки в нижний регистр,
		// и сравниваем строки. Так мы игнорируем регистр входной и искомой строки.
		if options.IgnoreCase && !options.Fixed {
			line = strings.ToLower(line)
			findStr = strings.ToLower(findStr)
		}
		if strings.Contains(line, findStr) && !options.Fixed {
			// res слайс для хранения индексов строк в которых обнаружено совпадение с искомой строкой.
			resIdx = append(resIdx, count)
		}
		if line == findStr && options.Fixed {
			// res слайс для хранения индексов строк в которых обнаружено совпадение с искомой строкой.
			resIdx = append(resIdx, count)
		}
		// count переменная которая хранит значение количества строк.
		count++
	}
	return
}

func printRes(allInput []string, resIdx []int) {
	if options.Invert {
		var j int
		for i, elem := range allInput {
			switch {
			case j < len(resIdx) && i == resIdx[j]:
				j++
			case options.LineNum:
				fmt.Println(i+1, elem)
			default:
				fmt.Println(elem)
			}
		}
	} else {
		for _, idx := range resIdx {
			switch {
			case options.LineNum:
				fmt.Println(idx+1, allInput[idx])
			default:
				fmt.Println(allInput[idx])
			}
		}
	}
}

func main() {
	// Работа с флагами.
	var args []string
	var err error

	if args, err = parser.Parse(); err != nil {
		switch flagsErr := err.(type) {
		case flags.ErrorType:
			if flagsErr == flags.ErrHelp {
				os.Exit(0)
			}
			os.Exit(1)
		default:
			os.Exit(1)
		}
	}

	//inputFilename := args[0]
	//findStr := args[1]

	fmt.Println(args)
	inputFilename := "input.txt"
	findStr := "мяч"

	f, err := os.Open(inputFilename)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	allInput, resIdx, count := grep(f, findStr)
	fmt.Println(resIdx)

	printRes(allInput, resIdx)

	if options.Count {
		fmt.Println("count line:", count)

	}
}

