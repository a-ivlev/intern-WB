// Реализовать быструю сортировку массива (quicksort) встроенными методами языка.
package main

import (
	"fmt"
)

func main() {
	arr := []int{17, -24, 20, -15, -21, -3, 13}
	Quicksort(arr)
	fmt.Println(arr)
}

// Quicksort производит быструю сортировку по алгоритму Хоара.
// Опорный элемент берётся из середины слайса который необходимо отсортировать.
// Количество шагов деления(глубина рекурсии) составляет приблизительно log n,
// если массив делится на более-менее равные части. Таким образом, общее быстродействие:
// O(n log n). 
func Quicksort(arr []int) {
	// Проверка, если массив состоит из одного элемента,
	// он считается отсортированным. Делаем возврат.
	if len(arr) <= 1 {
		return
	}

	// разбиваем массив на две части.
	split := partition(arr)

	// Рекурсивно запускаем Quicksort для левой части модмассива. 
	Quicksort(arr[:split])
	// Рекурсивно запускаем Quicksort для правой части модмассива. 
	Quicksort(arr[split:])
}


// partition определяет опроный элемент и разделяет слайс по этому элементу,
// так что слева от опорного элемента находятся числа меньше опорного, 
// а справа от опрного, все числа больше опорного.
func partition(arr []int) int {
	// Чем на более равные части будет делиться массив - тем лучше.
	// Поэтому, в качестве опорного элемента, целесообразно брать средний из трех,
	// а если массив достаточно велик - то из девяти произвольных элементов.
	pivot := mediana(arr[0], arr[len(arr)/2], arr[len(arr)-1])

	// установка указателей на исходные места
	left, right := 0, len(arr) - 1

	for {
		// Если элемент меньше опорного (pivot) передвигаем указатель влево
		// к следующему элементу, пока не найдём элемент больше опорного.
		for ; arr[left] < pivot; left++ {
		}
		// Если элемент больше опорного (pivot) передвигаем указатель вправо
		// к следующему элементу, пока не найдём элемент меньше опорного.
		for ; arr[right] > pivot; right-- {
		}

		// Проверяем не встретились ли наши указатели.
		if left >= right {
			return left
		}

		// Меняем местами найденые элементы. Это позволит получить слайс 
		// в котором слева от pivot (опрного элемента) все числа меньше pivot, 
		// а справа от pivot все числа больше pivot.
		arr[left], arr[right] = arr[right], arr[left]
	}
}

func mediana(arr ...int) int {
	// Сортировкой вставками отсортировываем массив
	// для определения медианы.
	for i := 1; i < len(arr); i++ {
		x := arr[i]
		j := i
		for ; j >= 1 && arr[j-1] > x; j-- {
			arr[j] = arr[j-1]
		}
		arr[j] = x
	}
	
	// После сортировки возвращаем медиану.
	return arr[len(arr)/2]
}
